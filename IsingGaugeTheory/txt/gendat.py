import sys
import numpy as np
import matplotlib.pyplot as plt


# this file takes data generated by MC of the Ising Gauge theory and enlarges it so that a regular convolution will take care of the
# periodic boundary conditions without modifications

# lattice
def plqu(lx):
  k=0
  ly=lx
  nh=2*lx*ly
  neig=np.zeros((lx*ly,4),dtype=np.int)
  for j in range(ly):
    for i in range(lx):
       if i<lx-1:
         neig[k,0]=k+1
         if j<ly-1:
          neig[k,1]=k+lx
         elif j==ly-1:
          neig[k,1]=k-(ly-1)*lx
         if i==0:
           neig[k,2]=k+lx-1
         else:
           neig[k,2]=k-1
       elif i==lx-1:
         neig[k,0]=k-(lx-1)
         if j<ly-1:
          neig[k,1]=k+lx
         elif j==ly-1:
          neig[k,1]=k-(ly-1)*lx
         neig[k,2]=k-1
       if j==0:
         neig[k,3]=k+(ly-1)*lx
       else:
         neig[k,3]=k-lx
       k=k+1

  plaquette=np.zeros((lx*ly,4),dtype=np.int)
  vertex=np.zeros((lx*ly,4),dtype=np.int)
#  print "table of plaquettes"
  for i in range(ly*lx):
    plaquette[i,0]=2*i
    plaquette[i,1]=2*i+1
    plaquette[i,2]=2*neig[i,0]+1
    plaquette[i,3]=2*neig[i,1]
    vertex[i,0]=2*i
    vertex[i,1]=2*i+1
    vertex[i,2]=2*neig[i,2]
    vertex[i,3]=2*neig[i,3]+1
    #print "p", i, plaquette[i,0],  plaquette[i,1], plaquette[i,2], plaquette[i,3]
    #print "v", i, vertex[i,0], vertex[i,1], vertex[i,2], vertex[i,3]
  return neig,plaquette,vertex

#lx=int(raw_input('lx'))
#training=int(raw_input('training'))
#bsize=int(raw_input('bsize'))
lx=12

test=np.loadtxt('Xtest.txt')
train=np.loadtxt('Xtrain.txt')

ly=lx
nh=lx*ly*2
nh_new=(lx+1)*(ly+1)*2
ntest=np.zeros((test.shape[0],nh_new))
ntrain=np.zeros((train.shape[0],nh_new))
neig,plaquette,vertex=plqu(lx)
k=0
kn=0
for j in range(ly+1):
 if j==ly:
     k=0 
 for i in range(lx+1):
  
    if i<lx:
     #print kn+1,k+1
     ntest[:,kn]=test[:,k]
     ntrain[:,kn]=train[:,k]
     kn=kn+1
     k=k+1
     #print kn+1,k+1 
     ntest[:,kn]=test[:,k]
     ntrain[:,kn]=train[:,k] 
     kn=kn+1
     k=k+1 
    elif i==lx:
     #print "neighs" 
     #print kn+1,2*neig[(k-1)/2,0] +1
     ntest[:,kn]=test[:,2*neig[(k-1)/2,0]]
     ntrain[:,kn]=train[:,2*neig[(k-1)/2,0]]
     kn=kn+1
     #print kn+1,2*neig[(k-1)/2,0]+1+1
     ntest[:,kn]=test[:,2*neig[(k-1)/2,0]+1]      
     ntrain[:,kn]=train[:,2*neig[(k-1)/2,0]+1] 
     kn=kn+1  
 

ytest=np.ones(test.shape[0],dtype=np.int)
ytest[0:test.shape[0]/2]=0

ytrain=np.ones(train.shape[0],dtype=np.int)
ytrain[0:train.shape[0]/2]=0


np.savetxt('ytestT.txt',ytest,fmt='%1.1d')
np.savetxt('XtestT.txt',ntest,fmt='%1.1d')

np.savetxt('ytrainT.txt',ytrain,fmt='%1.1d')
np.savetxt('XtrainT.txt',ntrain,fmt='%1.1d')
 
